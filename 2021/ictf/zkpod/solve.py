from zkpod import H
from math import gcd
from pwn import remote

N = 0xbb00128c1c1555dc8fc1cd09b3bb2c3efeaae016fcb336491bd022f83a10a501175c044843dbec0290c5f75d9a93710246361e4822331348e9bf40fc6810d5fc7315f37eb8f06fb3f0c0e9f63c2c207c29f367dc45eef2e5962eff35634b7a29d913a59cd0918fa395571d3901f8abd83322bd17b60fd0180358b7e36271adcfc1f9105b41da6950a17dba536a2b600f2dc35e88c4a9dd208ad85340de4d3c6025d1bd6e03e9449f83afa28b9ff814bd5662018be9170b2205f38cf3b67ba5909c81267daa711fcdb8c7844bbc943506e33f5f72f603119526072efbc5ceae785f2af634e6c7d2dd0d51d6cfd34a3bc2b15a752918d4090d2ca253df4ef47b8b
E = 0x10001
P = 0x199e1926f2d2d5967b1d230b33de0a249f958e5b962f8b82ca042970180fe1505607fe4c8cde04bc6d53aec53b4aa25255ae67051d6ed9b602b1b19e128835b20227db7ee19cf88660a50459108750f8b96c71847e4f38a79772a089aa46666404fd671ca17ea36ee9f401b4083f9ca76f5217588c6a15baba7eb4a0934e2026937812c96e2a5853c0e5a65231f3eb9fdc283e4177a97143fe1a3764dc87fd6d681f51f49f6eed5ab7ddc2a1da7206f77b8c7922c5f4a5cfa916b743ceeda943bc73d821d2f12354828817ff73bcd5800ed201c5ac66fa82df931c5bbc76e03e48720742ffe673b7786e40f243d7a0816c71eb641e5d58531242f7f5cfef60e5b
g = 2
X = 0xaa0d1c4e0119ccf47d9936af12ccb4381e8a9eb410aa58cde163edb4ec370d033ae44b2cc71519cb31b27161d6ca5ce1ad68a381f5f6ec42b1670adb145b70d5090695fa9ef2a03467754196e5d3ebb5128ad0f7295605d8224ccef0cad0ad7e1919b972cbc5a87489aa10757eb8f4326f1a50d737e27496b508641be46e6e32697c2d2a60160102a5f352e3f1493e8a7f0d56c45a57c193a104687ef28215488da0ad6fcb677474099cd533da1249916e358d0d23efd8c679cb9521f7442c97e657629208ce416421f0485acda717a5e463d0edd84dff873dd7af6a398aa4d083d45f5360ca7850432924d5d8a5ed3b6fca8108183ba3c64c5e7456dab8b01a

io = remote('chal.imaginaryctf.org', 42012)

def e(r): # Yeah I lied it's not *directly* e = H(r)
    return H(str(r).encode() + b"Haha, arbitrary message")

def sign(c):
    io.sendlineafter('> ', hex(c)[2:])
    r = int(io.recvline()[3:].decode())
    s = int(io.recvline()[3:].decode())
    if gcd(e(r), P-1) > 1: # If 1/e % P-1 doesn't exist, retry
        return sign(c)
    return r, s

def extract(r, s): # (r/g^s)^(1/e)
    return pow(r * pow(g, -s, P), pow(e(r), -1, P-1), P)

# gx = extract(*sign(X))
gx = 0x15354535a2e68dce4b39df34555b1a9fa95e210f97f43995d3cb4c432a8a103b722d791f8d4ae40c4aad32ffcff8b464fd82431ff419a24ab0b09ba40c326e53e08a4d09f19d422795789825a57355b132deaa62b0f930c1f1b557acd4dad7f296037a0535d7bd580f44f8b13c8e1e9b12a9058c8d6338883662ca845e737f0550df426766d3af3daed9c3e71096a04463799f7cfecf3a83215e5690966967168d09d86ae78db8c774e130f12a5f5a30c87b4901cf3247b38a083eb5bb98b8382de69ed271beb524f484974fbcaf3a273ff31167566d16d9e99d550d2c5a0a303efbe07f2bcafecb11563308f930bfaf29a0377c8f6b58085958b7174a1f1db38

def equals(a):
    c = X * pow(a, E, N) % N
    # True if a*x < N, False otherwise    
    return extract(*sign(c)) == pow(gx, a, P)

# Arbitrary upper/lower bounds to init search
# upper = N//2**(15*16)
# lower = N//2**(16*16)
# Below are the ones that were computed at the end of the script
upper = 26846122592259018338037918187112445806115546643529244210941171490456185005436733274157517111054922476310896938046544628509349774233755618398680437043105167267916976166362338350130873785791019720425004231792929986256029357546793477340832568657055158254018464460087533798420411242016424648974492754928154092040402484429657120414141532883549104064410986337961576931481667572074374347322627128338888037678366195891888624580881780980144417359645593189043693870050201306091452119702613376141623977161455318083889206781587724267
lower = 26846122592259018338037918187112445806115546643529244210941171490456185005436733274157517111054922476310896938046544628509349774233755618398680437043105167267916976166362338350130873785791019720425004231792929986256029357546793477340832568657055158254018464460087533798420411242016424648974492754928154092040402484429657120414141532883549104064410986337961576931481667572074374347322627128338888037678366195891888624580881780980144417359645593189043693870050201306091452119702613376141623977161455318083889206781587724268

from math import log2
print('Queries:', log2(upper - lower))

assert not equals(upper)
assert equals(lower)

while upper - lower > 1:
    try:
        mid = (upper + lower) // 2
        if equals(mid):
            lower = mid
        else:
            upper = mid
        print(upper, '> a >', lower)
    except EOFError: # Timeout
        io.close()
        io = remote('chal.imaginaryctf.org', 42012)

io.close()
print('='*210)
print('Lower multiplier:', lower)
print('Upper multiplier:', upper)

x = N//lower # There's only 1 bit of difference with N//upper so we can just test that
print(x.to_bytes((x.bit_length()+7)//8, 'big'))