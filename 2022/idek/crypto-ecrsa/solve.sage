import itertools as it

def find_factor(T, m):
    '''Find a factor of T, where m is a multiple of λ(T)'''
    v2m = int(log(m.p_primary_part(2), 2))
    for a in primes(isqrt(T)):
        for k in range(v2m):
            g = gcd(ZZ(pow(a, m//2^k, T)) - 1, T)
            if g not in { 1, T }:
                return g

    print('Found no factor!')

def factorize(N, m):
    '''Factorize N, where m is a multiple of λ(N)'''
    if is_prime(N):
        return factor(N)

    if N.is_perfect_power():
        A, e = N.perfect_power()
        return factorize(A)^e

    X = find_factor(N, m)
    return factorize(X, m) * factorize(N//X, m)

e = 3
d = 99193023581616109152177764300040037859521925088272985981669959946817746109531909713425474710564402873765914926441545005839662821744603138460681680285655317684469203777533871394260260583839662628325884473084768835902143240687542429953968760669321064892423877370896609497584167478711224462305776836476437268587
C = (115076663389968253954821343472300155800654332223208277786605760890770425514748910251950393842983935903563187546008731344369976804796963863865102277460894378910744413097852034635455187460730497479244094103353376650220792908529826147612199680141743585684118885745149209575053969106545841997245139943766220688789, 74232642959425795109854140949498935461683632963630260034964643066394703345139733396470958836932831941672213466233486926122670098721687149917605871805886006479766670309639660332339984667770417687192717160061980507220617662938436637445370463397769213554349920956877041619061811087875024276435043752581073552318)
U = (79615329406682121028641446306520032869660130854153788352536429332441749473394735222836513266191300847548366008281109415002581029448905418880962931523411475044527689429201653146200630804486870653795937020571749192405439450656659472253086567149309166068212312829071678837253421625687772396105149376211148834937, 114576105009077728778286635566905404081211824310970349548035698466418670695753458926421098950418414701335730404414509232776047250916535638430446206810902182305851611221604003509735478943147034397832291215478617613443375140890349118302843641726392253137668650493281241262406250679891685430326869028996183320982)

K.<a> = QQ[]
f = U[0]^3 + a*U[0] - U[1]^2 + C[1]^2 - C[0]^3 - a*C[0]
a = f.roots()[0][0]

t = ZZ(int.from_bytes(b'ECRSA offers added security by elliptic entropy.', 'big'))
b = 2^2 - t^3 - t*a
E = EllipticCurve(QQ, [a, b])
T = E(t, 2)

xt3, yt3 = (3*T).xy()
n = gcd(xt3.numer() - U[0]*xt3.denom(), yt3.numer() - U[1]*yt3.denom())
print('n =', n)
# Might need to run n through factorDB to remove small factors

fs = factorize(n, e*d - 1)
assert prod(fs) == n

ms = []
for p, _ in fs:
    Ep = EllipticCurve(GF(p), [a, b])
    ms.append([int(M[0]) for M in Ep(C).division_points(e)])

(p, _), (q, _) = fs
for mp, mq in it.product(*ms):
    m = CRT([mp, mq], [p, q])
    print(int(m).to_bytes(m.nbits()//8 + 1, 'big'))