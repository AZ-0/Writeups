# Finite Realm of Random

> I took a flag, and shuffled it. I took a part, and randomized it. I took the bits and pieces, and scattered them across the field. Now, only an haphazard mess remains.

| Category | Author   | Solves | Points | Expected Difficulty |
| -------- | -------- | ------ | ------ | ------------------- |
| Crypto   | A~Z      |    39  |   481  | Medium              |

## Understanding the challenge

This challenge was made to look like it is difficult, but the solve is in fact quite simple.
Once we understand what exactly this weird main file does we are basically done.

As can be seen in the `if __name__ == '__main__'` block, the flag is split in $16$-bytes part that are encrypted separately.
They are also shuffled, but that won't be a problem once we've decrypted.

The `as_poly_of` function has a very explicit name.
It takes two arguments $s$, $g$ and returns a polynomial $P$ over the base field such that $s = P(g)$.

Now to the meat of the challenge.
The `randomize` function starts very random with the following piece of code:
```py
L = GF(127)
for i in range(bits.nbits() -1):
    L = L['x'].irreducible_element(2, algorithm='random').splitting_field(f't{i}')
```
We know that $L$ will be isomorphic to $\mathbb F_{127^{32}}$.
But how is it constructed exactly?
Doesn't it depend on the polynomials that we randomly drew at each iteration?
It turns out that sagemath has a quirk that makes the result of the splitting field method constant.
This little bit of code is not random at all, and $L$ is gonna be the exact same extension each time you run it.
Neat, huh?

Now the flag part is turned into an element of the field:
```py
M = sum(c*L.gen()^i for i, c in enumerate(message))
```

Here comes the interesting part.
```py
m = M
while m == M:
    roots = L.random_element().minimal_polynomial().roots(L)
    shuffle(roots)

    try:
        (r1, _), (r2, _) = roots[:2]
        M = as_poly_of(M, r1)(r2)
    except:
        pass
```
This part of the code is run a random amount of times.
It selects a random element $r$, a random conjugate $s$ of $r$, expresses $M$ as $M = P(r)$ for some polynomial $P\in\mathbb F_{127}[X]$, and turns it into $M' = P(s)$.
What is going on?

Let $k=\mathbb F_{127}$ and consider the isomorphism from $k(r)$ to $k(s)$ given by $\sigma: r\mapsto s$.
It just so happens that $\sigma$ can be lifted into an automorphism of $L$, for it is a normal extension containing $r$ and $s$.

All in all, the code computes $M' =\tau(M) = \sigma_n\cdots\sigma_2\sigma_1(M)$ for some random automorphisms $\sigma_i:L\to L$.
The composite of automorphisms is itself an automorphism, so that $\tau\in\mathrm{Gal}(L/k)$.
Now Galois theory provides us with the following fun facts:
- $|\mathrm{Gal}(L/K)| = [L:k] = 32$, because all finite fields are separable.
- $\mathrm{Gal}(L/k)$ is cyclic, generated by the Frobenius automorphism $\pi:x\mapsto x^p$.

This means that $\tau=\pi^n$ for some $n\in\llbracket 1,32\rrbracket$.
This also means that $\tau^{-1}=\pi^{32-n}$.
To derandomize the message, we only need to compute $\pi^i(M')$ for all $1\leq i\leq 32$ to eventually retrieve the flag part!

```py
with open('out.txt', 'r') as file:
    x = bytes.fromhex(file.read())

x = [*map(ZZ, x)]
p = 127
E = GF(p^32, 't')
Ï€ = E.frobenius_endomorphism()

for i in range(0, len(x), 32):
    c = E([ZZ(y) for y in x[i:i+32]])

    for f in Ï€.powers(E.degree()):
        m = f(c).polynomial()
        if m.degree() < 16:
            print(*map(chr, m.list()), sep='')
```

Putting the pieces back in order, we obtain: `idek{4nd_7hu5_5p0k3_G4!015:_7h3_f1n1t3_r34Lm_sh4ll_n07_h4rb0ur_r4nd0mn355,_0n!y_7h3_fr0b3n1u5__}`. ðŸŽ‰

The solve script is given in [`solve.sage`](./solve.sage).